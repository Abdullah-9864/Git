<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Data Structures â€” Complete Guide</title>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700;900&family=IBM+Plex+Mono:wght@400;600&family=Lato:wght@300;400;700&display=swap" rel="stylesheet"/>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0;}

:root{
  --bg:#f5f0e8;
  --paper:#fffef9;
  --ink:#1a1209;
  --muted:#6b5f4a;
  --accent:#c0392b;
  --accent2:#2c7a4b;
  --accent3:#1a5276;
  --accent4:#7d3c98;
  --border:#d4c9b0;
  --code-bg:#1a1209;
  --code-text:#f5f0e8;
}

body{
  background:var(--bg);
  color:var(--ink);
  font-family:'Lato',sans-serif;
  font-weight:300;
  line-height:1.8;
}

/* SIDEBAR NAV */
.sidebar{
  position:fixed;
  left:0;top:0;bottom:0;
  width:260px;
  background:var(--ink);
  color:var(--bg);
  overflow-y:auto;
  z-index:100;
  padding:30px 0;
}

.sidebar-title{
  font-family:'Playfair Display',serif;
  font-size:1.1rem;
  padding:0 24px 20px;
  border-bottom:1px solid #333;
  color:#e8dcc8;
  letter-spacing:0.05em;
}

.sidebar ul{list-style:none;margin-top:16px;}
.sidebar ul li a{
  display:block;
  padding:8px 24px;
  color:#a0907a;
  text-decoration:none;
  font-size:0.82rem;
  transition:all 0.2s;
  border-left:3px solid transparent;
}
.sidebar ul li a:hover{
  color:#f5f0e8;
  border-left-color:var(--accent);
  background:rgba(255,255,255,0.05);
}
.sidebar ul li.chapter > a{
  color:#e8dcc8;
  font-weight:700;
  font-size:0.88rem;
  margin-top:12px;
  text-transform:uppercase;
  letter-spacing:0.1em;
}

/* MAIN CONTENT */
.main{
  margin-left:260px;
  padding:60px 80px;
  max-width:1000px;
}

/* HERO */
.hero{
  text-align:center;
  padding:80px 0 60px;
  border-bottom:2px solid var(--border);
  margin-bottom:80px;
}

.hero .edition{
  font-size:0.8rem;
  letter-spacing:0.3em;
  text-transform:uppercase;
  color:var(--muted);
  margin-bottom:20px;
}

.hero h1{
  font-family:'Playfair Display',serif;
  font-size:3.5rem;
  line-height:1.1;
  color:var(--ink);
  margin-bottom:16px;
}

.hero h1 span{color:var(--accent);}

.hero p{
  color:var(--muted);
  font-size:1.1rem;
  max-width:500px;
  margin:0 auto 30px;
}

.hero .divider{
  width:60px;height:3px;
  background:var(--accent);
  margin:0 auto;
}

/* CHAPTER */
.chapter{
  margin-bottom:100px;
}

.chapter-header{
  display:flex;
  align-items:center;
  gap:20px;
  margin-bottom:40px;
  padding-bottom:20px;
  border-bottom:2px solid var(--border);
}

.chapter-num{
  font-family:'Playfair Display',serif;
  font-size:4rem;
  color:var(--border);
  line-height:1;
  min-width:80px;
}

.chapter-title{
  font-family:'Playfair Display',serif;
  font-size:2rem;
  color:var(--ink);
}

.chapter-subtitle{
  color:var(--muted);
  font-size:0.9rem;
  margin-top:4px;
}

/* SECTION */
.section{margin-bottom:50px;}

h3{
  font-family:'Playfair Display',serif;
  font-size:1.4rem;
  color:var(--ink);
  margin-bottom:16px;
  padding-left:14px;
  border-left:4px solid var(--accent);
}

h4{
  font-weight:700;
  font-size:1rem;
  color:var(--ink);
  margin:24px 0 10px;
  text-transform:uppercase;
  letter-spacing:0.1em;
  font-size:0.85rem;
}

p{
  margin-bottom:16px;
  font-size:1rem;
  color:#2a1f0f;
}

/* CALLOUT BOXES */
.callout{
  border-radius:8px;
  padding:20px 24px;
  margin:24px 0;
  border-left:5px solid;
}

.callout-note{background:#fef9e7;border-color:#f39c12;}
.callout-tip{background:#eafaf1;border-color:var(--accent2);}
.callout-warning{background:#fdf2f8;border-color:var(--accent4);}
.callout-key{background:#ebf5fb;border-color:var(--accent3);}

.callout-label{
  font-weight:700;
  font-size:0.75rem;
  letter-spacing:0.15em;
  text-transform:uppercase;
  margin-bottom:8px;
}

.callout-note .callout-label{color:#f39c12;}
.callout-tip .callout-label{color:var(--accent2);}
.callout-warning .callout-label{color:var(--accent4);}
.callout-key .callout-label{color:var(--accent3);}

/* CODE BLOCKS */
.code-block{
  background:var(--code-bg);
  border-radius:10px;
  overflow:hidden;
  margin:20px 0;
  font-family:'IBM Plex Mono',monospace;
}

.code-header{
  background:#2d2416;
  padding:10px 20px;
  font-size:0.75rem;
  color:#a0907a;
  letter-spacing:0.1em;
  text-transform:uppercase;
  display:flex;
  align-items:center;
  gap:8px;
}

.code-dot{width:10px;height:10px;border-radius:50%;}
.dot-r{background:#ff5f56;}
.dot-y{background:#ffbd2e;}
.dot-g{background:#27c93f;}

.code-body{
  padding:20px 24px;
  font-size:0.85rem;
  line-height:1.7;
  overflow-x:auto;
  color:var(--code-text);
}

.kw{color:#ff79c6;}
.fn{color:#50fa7b;}
.cm{color:#6272a4;font-style:italic;}
.st{color:#f1fa8c;}
.nm{color:#bd93f9;}
.tp{color:#8be9fd;}

/* MEMORY DIAGRAM */
.mem-diagram{
  background:#fff;
  border:2px solid var(--border);
  border-radius:10px;
  padding:24px;
  margin:20px 0;
  font-family:'IBM Plex Mono',monospace;
  font-size:0.85rem;
  overflow-x:auto;
}

.mem-title{
  font-family:'Lato',sans-serif;
  font-weight:700;
  font-size:0.75rem;
  text-transform:uppercase;
  letter-spacing:0.15em;
  color:var(--muted);
  margin-bottom:16px;
}

.mem-row{display:flex;align-items:center;gap:4px;margin:6px 0;}

.mem-box{
  width:60px;height:40px;
  border:2px solid var(--border);
  display:flex;align-items:center;justify-content:center;
  font-weight:600;
  border-radius:4px;
  font-size:0.85rem;
}

.mem-box.filled{background:#ebf5fb;border-color:var(--accent3);color:var(--accent3);}
.mem-box.pointer{background:#eafaf1;border-color:var(--accent2);color:var(--accent2);}
.mem-box.null{background:#fdf2f8;border-color:var(--accent4);color:var(--accent4);}
.mem-box.highlight{background:#fef9e7;border-color:#f39c12;color:#f39c12;}

.mem-label{color:var(--muted);font-size:0.75rem;margin-left:8px;}
.mem-arrow{color:var(--accent3);font-size:1.2rem;margin:0 4px;}

/* TABLE */
.comp-table{
  width:100%;
  border-collapse:collapse;
  margin:20px 0;
  font-size:0.9rem;
}

.comp-table th{
  background:var(--ink);
  color:var(--bg);
  padding:12px 16px;
  text-align:left;
  font-size:0.8rem;
  letter-spacing:0.1em;
  text-transform:uppercase;
}

.comp-table td{
  padding:11px 16px;
  border-bottom:1px solid var(--border);
}

.comp-table tr:hover td{background:#faf6ee;}

.badge{
  display:inline-block;
  padding:2px 10px;
  border-radius:20px;
  font-size:0.75rem;
  font-weight:700;
}

.badge-green{background:#d5f5e3;color:#1e8449;}
.badge-red{background:#fadbd8;color:#922b21;}
.badge-blue{background:#d6eaf8;color:#1a5276;}
.badge-yellow{background:#fef9e7;color:#9a7d0a;}

/* ANALOGY BOX */
.analogy{
  background:linear-gradient(135deg,#1a1209,#2d2416);
  color:#f5f0e8;
  border-radius:10px;
  padding:24px 28px;
  margin:24px 0;
}

.analogy-label{
  font-size:0.75rem;
  letter-spacing:0.2em;
  text-transform:uppercase;
  color:#a0907a;
  margin-bottom:10px;
}

.analogy p{color:#e8dcc8;margin-bottom:0;}

/* QUIZ */
.quiz{
  background:#fff;
  border:2px solid var(--border);
  border-radius:10px;
  padding:24px;
  margin:30px 0;
}

.quiz-label{
  font-size:0.75rem;
  letter-spacing:0.2em;
  text-transform:uppercase;
  color:var(--accent);
  font-weight:700;
  margin-bottom:12px;
}

.quiz p{margin-bottom:0;font-weight:700;}

/* PROGRESS */
.toc-progress{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  margin:30px 0;
}

.toc-item{
  background:#fff;
  border:1px solid var(--border);
  border-radius:8px;
  padding:10px 16px;
  font-size:0.82rem;
  color:var(--muted);
  text-decoration:none;
  transition:all 0.2s;
}

.toc-item:hover{border-color:var(--accent);color:var(--accent);}

/* SCROLLBAR */
::-webkit-scrollbar{width:6px;height:6px;}
::-webkit-scrollbar-track{background:transparent;}
::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px;}
</style>
</head>
<body>

<!-- SIDEBAR -->
<nav class="sidebar">
  <div class="sidebar-title">ğŸ“š Data Structures</div>
  <ul>
    <li class="chapter"><a href="#ch0">Introduction</a></li>
    <li><a href="#ch0">What are Data Structures?</a></li>
    <li><a href="#types">Types Overview</a></li>

    <li class="chapter"><a href="#ch1">Chapter 1</a></li>
    <li><a href="#ch1">Arrays</a></li>
    <li><a href="#static">Static Arrays</a></li>
    <li><a href="#dynamic">Dynamic Arrays</a></li>

    <li class="chapter"><a href="#ch2">Chapter 2</a></li>
    <li><a href="#ch2">Linked Lists</a></li>
    <li><a href="#singly">Singly Linked List</a></li>
    <li><a href="#doubly">Doubly Linked List</a></li>
    <li><a href="#stl-list">STL list</a></li>

    <li class="chapter"><a href="#ch3">Chapter 3</a></li>
    <li><a href="#ch3">Stack</a></li>

    <li class="chapter"><a href="#ch4">Chapter 4</a></li>
    <li><a href="#ch4">Queue</a></li>

    <li class="chapter"><a href="#ch5">Chapter 5</a></li>
    <li><a href="#ch5">Trees</a></li>

    <li class="chapter"><a href="#summary">Summary</a></li>
  </ul>
</nav>

<!-- MAIN -->
<div class="main">

  <!-- HERO -->
  <div class="hero">
    <div class="edition">Complete Beginner's Guide</div>
    <h1>Data <span>Structures</span><br/>in C++</h1>
    <p>From zero to understanding â€” every concept explained clearly with code and diagrams.</p>
    <div class="divider"></div>
  </div>

  <!-- =================== INTRO =================== -->
  <div class="chapter" id="ch0">
    <div class="chapter-header">
      <div class="chapter-num">00</div>
      <div>
        <div class="chapter-title">Introduction</div>
        <div class="chapter-subtitle">What are Data Structures and why do we need them?</div>
      </div>
    </div>

    <div class="section">
      <h3>What is a Data Structure?</h3>
      <p>A <strong>data structure</strong> is a way of organizing and storing data in memory so that it can be accessed and modified efficiently.</p>
      <p>Think of it like this â€” you have 1000 student names. You could dump them all randomly, OR you could organize them in a sorted list, a folder system, or an indexed table. The way you organize them is the data structure!</p>

      <div class="analogy">
        <div class="analogy-label">ğŸ“¦ Real World Analogy</div>
        <p>A <strong>library</strong> is a data structure. Books are organized by genre, then author, then title. This organization lets you find any book quickly. Without organization, you'd have to search every single book!</p>
      </div>
    </div>

    <div class="section" id="types">
      <h3>Types of Data Structures</h3>

      <div class="mem-diagram">
        <div class="mem-title">Complete Hierarchy</div>
<pre style="color:#2a1f0f;font-size:0.85rem;line-height:2;">
                    DATA STRUCTURES
                    /             \
             Primitive          Non-Primitive
           /    |    \            /         \
         int  char  bool       Linear    Non-Linear
        float double          /  |  \      /     \
                           Array Stack Queue  Tree  Graph
                          Linked
                           List
</pre>
      </div>

      <table class="comp-table">
        <thead>
          <tr><th>Type</th><th>Category</th><th>Access</th><th>Use Case</th></tr>
        </thead>
        <tbody>
          <tr><td><strong>Array</strong></td><td><span class="badge badge-blue">Linear</span></td><td>By index</td><td>Fixed size collections</td></tr>
          <tr><td><strong>Linked List</strong></td><td><span class="badge badge-blue">Linear</span></td><td>Sequential</td><td>Dynamic insertions</td></tr>
          <tr><td><strong>Stack</strong></td><td><span class="badge badge-blue">Linear</span></td><td>LIFO</td><td>Undo, backtracking</td></tr>
          <tr><td><strong>Queue</strong></td><td><span class="badge badge-blue">Linear</span></td><td>FIFO</td><td>Scheduling, printing</td></tr>
          <tr><td><strong>Tree</strong></td><td><span class="badge badge-yellow">Non-Linear</span></td><td>Hierarchical</td><td>File systems, databases</td></tr>
          <tr><td><strong>Graph</strong></td><td><span class="badge badge-yellow">Non-Linear</span></td><td>Any order</td><td>Maps, networks</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- =================== CHAPTER 1: ARRAYS =================== -->
  <div class="chapter" id="ch1">
    <div class="chapter-header">
      <div class="chapter-num">01</div>
      <div>
        <div class="chapter-title">Arrays</div>
        <div class="chapter-subtitle">The simplest and most fundamental data structure</div>
      </div>
    </div>

    <div class="section">
      <h3>What is an Array?</h3>
      <p>An array is a collection of elements of the <strong>same data type</strong> stored in <strong>consecutive memory locations</strong>. Each element is accessed using an <strong>index</strong> starting from 0.</p>

      <div class="mem-diagram">
        <div class="mem-title">Array in Memory â€” int arr[5] = {10,20,30,40,50}</div>
        <div class="mem-row">
          <div class="mem-box filled">10</div>
          <div class="mem-box filled">20</div>
          <div class="mem-box filled">30</div>
          <div class="mem-box filled">40</div>
          <div class="mem-box filled">50</div>
          <span class="mem-label">â† values</span>
        </div>
        <div class="mem-row">
          <div class="mem-box" style="border:none;color:#a0907a;">[0]</div>
          <div class="mem-box" style="border:none;color:#a0907a;">[1]</div>
          <div class="mem-box" style="border:none;color:#a0907a;">[2]</div>
          <div class="mem-box" style="border:none;color:#a0907a;">[3]</div>
          <div class="mem-box" style="border:none;color:#a0907a;">[4]</div>
          <span class="mem-label">â† index</span>
        </div>
        <div class="mem-row" style="margin-top:8px;">
          <div class="mem-box" style="border:none;color:#a0907a;font-size:0.7rem;">1000</div>
          <div class="mem-box" style="border:none;color:#a0907a;font-size:0.7rem;">1004</div>
          <div class="mem-box" style="border:none;color:#a0907a;font-size:0.7rem;">1008</div>
          <div class="mem-box" style="border:none;color:#a0907a;font-size:0.7rem;">1012</div>
          <div class="mem-box" style="border:none;color:#a0907a;font-size:0.7rem;">1016</div>
          <span class="mem-label">â† address (+4 each because int = 4 bytes)</span>
        </div>
      </div>

      <div class="callout callout-key">
        <div class="callout-label">ğŸ”‘ Key Rule</div>
        Index always starts from <strong>0</strong>. For an array of size N, valid indexes are <strong>0 to N-1</strong>.
      </div>
    </div>

    <div class="section" id="static">
      <h3>Static Arrays</h3>
      <p>Size is <strong>fixed at compile time</strong>. You must know the size before running the program. Stored in <strong>Stack memory</strong>.</p>

      <div class="code-block">
        <div class="code-header"><div class="code-dot dot-r"></div><div class="code-dot dot-y"></div><div class="code-dot dot-g"></div>static_array.cpp</div>
        <div class="code-body"><pre><span class="kw">#include</span><span class="st">&lt;iostream&gt;</span>
<span class="kw">using namespace</span> std;

<span class="tp">int</span> <span class="fn">main</span>() {
    <span class="cm">// Declare static array â€” size is FIXED = 5</span>
    <span class="tp">int</span> nums[<span class="nm">5</span>] = {<span class="nm">10</span>, <span class="nm">20</span>, <span class="nm">30</span>, <span class="nm">40</span>, <span class="nm">50</span>};

    <span class="cm">// Access elements using index</span>
    cout &lt;&lt; nums[<span class="nm">0</span>];   <span class="cm">// 10 â€” first element</span>
    cout &lt;&lt; nums[<span class="nm">4</span>];   <span class="cm">// 50 â€” last element</span>

    <span class="cm">// Loop through all elements</span>
    <span class="kw">for</span>(<span class="tp">int</span> i = <span class="nm">0</span>; i &lt; <span class="nm">5</span>; i++) {
        cout &lt;&lt; nums[i] &lt;&lt; <span class="st">" "</span>;
    }
    <span class="cm">// Output: 10 20 30 40 50</span>

    <span class="kw">return</span> <span class="nm">0</span>;
}</pre></div>
      </div>

      <div class="callout callout-warning">
        <div class="callout-label">âš ï¸ Limitation</div>
        You CANNOT add a 6th element to a size-5 array. The size is locked forever!
      </div>
    </div>

    <div class="section" id="dynamic">
      <h3>Dynamic Arrays</h3>
      <p>Size is decided <strong>at runtime</strong>. The user can choose the size while the program runs. Stored in <strong>Heap memory</strong> using pointers and <code>new</code>.</p>

      <div class="code-block">
        <div class="code-header"><div class="code-dot dot-r"></div><div class="code-dot dot-y"></div><div class="code-dot dot-g"></div>dynamic_array.cpp</div>
        <div class="code-body"><pre><span class="kw">#include</span><span class="st">&lt;iostream&gt;</span>
<span class="kw">using namespace</span> std;

<span class="tp">int</span> <span class="fn">main</span>() {
    <span class="tp">int</span> size;
    cout &lt;&lt; <span class="st">"Enter size: "</span>;
    cin &gt;&gt; size;   <span class="cm">// user decides size at runtime!</span>

    <span class="cm">// new int[size] = create 'size' boxes in HEAP</span>
    <span class="cm">// int* arr     = pointer storing address of first box</span>
    <span class="tp">int</span>* arr = <span class="kw">new</span> <span class="tp">int</span>[size];

    <span class="cm">// Fill the array</span>
    <span class="kw">for</span>(<span class="tp">int</span> i = <span class="nm">0</span>; i &lt; size; i++) {
        cout &lt;&lt; <span class="st">"Enter element: "</span>;
        cin &gt;&gt; arr[i];
    }

    <span class="cm">// Print the array</span>
    <span class="kw">for</span>(<span class="tp">int</span> i = <span class="nm">0</span>; i &lt; size; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; <span class="st">" "</span>;
    }

    <span class="cm">// MUST free memory when done!</span>
    <span class="kw">delete</span>[] arr;
    <span class="kw">return</span> <span class="nm">0</span>;
}</pre></div>
      </div>

      <div class="mem-diagram">
        <div class="mem-title">Dynamic Array in Memory</div>
<pre style="color:#2a1f0f;font-size:0.82rem;line-height:2;">
STACK                        HEAP
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚ arr = 0x2000 â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ 10 â”‚ 20 â”‚ 30 â”‚ 40 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
  (pointer, 8 bytes)         (actual data, heap)
</pre>
      </div>

      <table class="comp-table">
        <thead><tr><th></th><th>Static Array</th><th>Dynamic Array</th></tr></thead>
        <tbody>
          <tr><td>Size</td><td><span class="badge badge-red">Fixed</span></td><td><span class="badge badge-green">Flexible</span></td></tr>
          <tr><td>Memory</td><td>Stack</td><td>Heap</td></tr>
          <tr><td>Syntax</td><td><code>int arr[5]</code></td><td><code>new int[size]</code></td></tr>
          <tr><td>Cleanup</td><td>Automatic</td><td>Manual <code>delete[]</code></td></tr>
          <tr><td>Speed</td><td><span class="badge badge-green">Faster</span></td><td>Slightly slower</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- =================== CHAPTER 2: LINKED LIST =================== -->
  <div class="chapter" id="ch2">
    <div class="chapter-header">
      <div class="chapter-num">02</div>
      <div>
        <div class="chapter-title">Linked Lists</div>
        <div class="chapter-subtitle">Dynamic chains of nodes connected by pointers</div>
      </div>
    </div>

    <div class="section">
      <h3>What is a Linked List?</h3>
      <p>A linked list is a chain of <strong>nodes</strong> where each node contains data AND a pointer to the next node. Unlike arrays, nodes are <strong>NOT stored consecutively</strong> â€” they are scattered in memory and connected by pointers.</p>

      <div class="mem-diagram">
        <div class="mem-title">Linked List vs Array</div>
<pre style="color:#2a1f0f;font-size:0.82rem;line-height:2;">
ARRAY â€” consecutive memory:
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚ 10 â”‚ 20 â”‚ 30 â”‚ 40 â”‚   addresses: 1000, 1004, 1008, 1012
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

LINKED LIST â€” scattered memory:
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ 10 â”‚2034â”‚â”€â”€â”€â”€â–¶â”‚ 20 â”‚3078â”‚â”€â”€â”€â”€â–¶â”‚ 30 â”‚ NULL â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
addr:1001        addr:2034        addr:3078
</pre>
      </div>

      <h4>What does a Node look like?</h4>
      <div class="code-block">
        <div class="code-header"><div class="code-dot dot-r"></div><div class="code-dot dot-y"></div><div class="code-dot dot-g"></div>node structure</div>
        <div class="code-body"><pre><span class="kw">struct</span> <span class="tp">Node</span> {
    <span class="tp">int</span> data;       <span class="cm">// stores the VALUE</span>
    <span class="tp">Node</span>* next;     <span class="cm">// stores ADDRESS of next node</span>
};

<span class="cm">// Each node looks like this in memory:</span>
<span class="cm">// â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="cm">// â”‚ data â”‚   next   â”‚</span>
<span class="cm">// â”‚  10  â”‚  0x2034  â”‚â”€â”€â–¶ (points to next node)</span>
<span class="cm">// â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span></pre></div>
      </div>
    </div>

    <div class="section" id="singly">
      <h3>Singly Linked List</h3>
      <p>Each node has only <strong>ONE pointer</strong> â€” pointing to the <strong>next</strong> node. You can only traverse <strong>forward</strong>.</p>

      <div class="mem-diagram">
        <div class="mem-title">Singly Linked List</div>
<pre style="color:#2a1f0f;font-size:0.82rem;line-height:2;">
head
 â†“
[10|next]â”€â”€â–¶[20|next]â”€â”€â–¶[30|next]â”€â”€â–¶[40|NULL]

Each node has: data + ONE pointer (forward only â¡ï¸)
</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><div class="code-dot dot-r"></div><div class="code-dot dot-y"></div><div class="code-dot dot-g"></div>singly_linked_list.cpp</div>
        <div class="code-body"><pre><span class="kw">#include</span><span class="st">&lt;iostream&gt;</span>
<span class="kw">using namespace</span> std;

<span class="cm">// Step 1: Define Node structure</span>
<span class="kw">struct</span> <span class="tp">Node</span> {
    <span class="tp">int</span> data;
    <span class="tp">Node</span>* next;

    <span class="cm">// Constructor to create node easily</span>
    <span class="fn">Node</span>(<span class="tp">int</span> val) {
        data = val;
        next = <span class="kw">nullptr</span>;
    }
};

<span class="cm">// Step 2: Define Linked List</span>
<span class="kw">class</span> <span class="tp">LinkedList</span> {
<span class="kw">public</span>:
    <span class="tp">Node</span>* head;

    <span class="fn">LinkedList</span>() { head = <span class="kw">nullptr</span>; }

    <span class="cm">// Add node at END</span>
    <span class="tp">void</span> <span class="fn">addEnd</span>(<span class="tp">int</span> val) {
        <span class="tp">Node</span>* newNode = <span class="kw">new</span> <span class="tp">Node</span>(val);
        <span class="kw">if</span>(head == <span class="kw">nullptr</span>) { head = newNode; <span class="kw">return</span>; }
        <span class="tp">Node</span>* curr = head;
        <span class="kw">while</span>(curr->next != <span class="kw">nullptr</span>) curr = curr->next;
        curr->next = newNode;
    }

    <span class="cm">// Print all nodes</span>
    <span class="tp">void</span> <span class="fn">print</span>() {
        <span class="tp">Node</span>* curr = head;
        <span class="kw">while</span>(curr != <span class="kw">nullptr</span>) {
            cout &lt;&lt; curr->data &lt;&lt; <span class="st">" â”€â”€â–¶ "</span>;
            curr = curr->next;
        }
        cout &lt;&lt; <span class="st">"NULL"</span> &lt;&lt; endl;
    }
};

<span class="tp">int</span> <span class="fn">main</span>() {
    <span class="tp">LinkedList</span> list;
    list.<span class="fn">addEnd</span>(<span class="nm">10</span>);
    list.<span class="fn">addEnd</span>(<span class="nm">20</span>);
    list.<span class="fn">addEnd</span>(<span class="nm">30</span>);
    list.<span class="fn">print</span>();
    <span class="cm">// Output: 10 â”€â”€â–¶ 20 â”€â”€â–¶ 30 â”€â”€â–¶ NULL</span>
    <span class="kw">return</span> <span class="nm">0</span>;
}</pre></div>
      </div>
    </div>

    <div class="section" id="doubly">
      <h3>Doubly Linked List</h3>
      <p>Each node has <strong>TWO pointers</strong> â€” one pointing <strong>forward (next)</strong> and one pointing <strong>backward (prev)</strong>. You can traverse in <strong>both directions</strong>.</p>

      <div class="mem-diagram">
        <div class="mem-title">Doubly Linked List</div>
<pre style="color:#2a1f0f;font-size:0.82rem;line-height:2;">
     head
      â†“
NULLâ†[10|next]â‡„[20|next]â‡„[30|next]â†’NULL
     [prev|10] [prev|20] [prev|30]

Each node has: prev pointer + data + next pointer
Can go BOTH ways â¡ï¸ â¬…ï¸
</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><div class="code-dot dot-r"></div><div class="code-dot dot-y"></div><div class="code-dot dot-g"></div>doubly_linked_list.cpp</div>
        <div class="code-body"><pre><span class="kw">struct</span> <span class="tp">Node</span> {
    <span class="tp">int</span> data;
    <span class="tp">Node</span>* next;   <span class="cm">// points FORWARD â¡ï¸</span>
    <span class="tp">Node</span>* prev;   <span class="cm">// points BACKWARD â¬…ï¸</span>

    <span class="fn">Node</span>(<span class="tp">int</span> val) {
        data = val;
        next = <span class="kw">nullptr</span>;
        prev = <span class="kw">nullptr</span>;
    }
};</pre></div>
      </div>

      <table class="comp-table">
        <thead><tr><th></th><th>Singly</th><th>Doubly</th></tr></thead>
        <tbody>
          <tr><td>Pointers per node</td><td>1 (next only)</td><td>2 (next + prev)</td></tr>
          <tr><td>Direction</td><td>â¡ï¸ Forward only</td><td>â¡ï¸â¬…ï¸ Both ways</td></tr>
          <tr><td>Memory per node</td><td>Less</td><td>More</td></tr>
          <tr><td>Reverse traversal</td><td><span class="badge badge-red">No</span></td><td><span class="badge badge-green">Yes</span></td></tr>
          <tr><td>C++ STL</td><td><code>forward_list</code></td><td><code>list</code></td></tr>
        </tbody>
      </table>
    </div>

    <div class="section" id="stl-list">
      <h3>STL list â€” Built-in Doubly Linked List</h3>
      <p>C++ already has a <strong>built-in doubly linked list</strong> called <code>list</code> in the STL library. You don't need to build it from scratch!</p>

      <div class="callout callout-tip">
        <div class="callout-label">ğŸ’¡ Remember</div>
        <code>#include&lt;list&gt;</code> = Doubly Linked List &nbsp;|&nbsp; <code>#include&lt;forward_list&gt;</code> = Singly Linked List
      </div>

      <div class="code-block">
        <div class="code-header"><div class="code-dot dot-r"></div><div class="code-dot dot-y"></div><div class="code-dot dot-g"></div>stl_list.cpp</div>
        <div class="code-body"><pre><span class="kw">#include</span><span class="st">&lt;iostream&gt;</span>
<span class="kw">#include</span><span class="st">&lt;list&gt;</span>        <span class="cm">// doubly linked list</span>
<span class="kw">using namespace</span> std;

<span class="tp">int</span> <span class="fn">main</span>() {
    list&lt;<span class="tp">int</span>&gt; L;

    L.<span class="fn">push_back</span>(<span class="nm">10</span>);    <span class="cm">// add to END</span>
    L.<span class="fn">push_back</span>(<span class="nm">20</span>);
    L.<span class="fn">push_back</span>(<span class="nm">30</span>);
    L.<span class="fn">push_front</span>(<span class="nm">5</span>);    <span class="cm">// add to FRONT</span>

    <span class="cm">// Forward â¡ï¸ (only possible because doubly linked)</span>
    cout &lt;&lt; <span class="st">"Forward:  "</span>;
    <span class="kw">for</span>(<span class="kw">auto</span> it = L.<span class="fn">begin</span>(); it != L.<span class="fn">end</span>(); it++)
        cout &lt;&lt; *it &lt;&lt; <span class="st">" "</span>;   <span class="cm">// 5 10 20 30</span>

    <span class="cm">// Backward â¬…ï¸ (only possible because doubly linked!)</span>
    cout &lt;&lt; <span class="st">"\nBackward: "</span>;
    <span class="kw">for</span>(<span class="kw">auto</span> it = L.<span class="fn">rbegin</span>(); it != L.<span class="fn">rend</span>(); it++)
        cout &lt;&lt; *it &lt;&lt; <span class="st">" "</span>;   <span class="cm">// 30 20 10 5</span>

    <span class="kw">return</span> <span class="nm">0</span>;
}</pre></div>
      </div>
    </div>
  </div>

  <!-- =================== CHAPTER 3: STACK =================== -->
  <div class="chapter" id="ch3">
    <div class="chapter-header">
      <div class="chapter-num">03</div>
      <div>
        <div class="chapter-title">Stack</div>
        <div class="chapter-subtitle">Last In, First Out â€” like a stack of plates</div>
      </div>
    </div>

    <div class="section">
      <h3>What is a Stack?</h3>
      <p>A stack is a linear data structure where elements are added and removed from the <strong>same end</strong> called the <strong>top</strong>. It follows the <strong>LIFO</strong> principle â€” Last In, First Out.</p>

      <div class="analogy">
        <div class="analogy-label">ğŸ½ï¸ Analogy</div>
        <p>Think of a stack of plates. You always add a new plate on TOP and always take the plate from the TOP. You can never take from the middle or bottom!</p>
      </div>

      <div class="mem-diagram">
        <div class="mem-title">Stack Operations</div>
<pre style="color:#2a1f0f;font-size:0.82rem;line-height:2;">
push(10)  push(20)  push(30)  pop()     pop()
  â”Œâ”€â”€â”      â”Œâ”€â”€â”      â”Œ30â”     â”Œâ”€â”€â”     â”Œâ”€â”€â”
  â”‚  â”‚      â”‚20â”‚      â”‚20â”‚     â”‚20â”‚     â”‚  â”‚
  â”‚10â”‚      â”‚10â”‚      â”‚10â”‚     â”‚10â”‚     â”‚10â”‚
  â””â”€â”€â”˜      â””â”€â”€â”˜      â””â”€â”€â”˜     â””â”€â”€â”˜     â””â”€â”€â”˜
top=10    top=20    top=30   top=20   top=10
                             30 removed! 20 removed!
</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><div class="code-dot dot-r"></div><div class="code-dot dot-y"></div><div class="code-dot dot-g"></div>stack.cpp</div>
        <div class="code-body"><pre><span class="kw">#include</span><span class="st">&lt;iostream&gt;</span>
<span class="kw">#include</span><span class="st">&lt;stack&gt;</span>
<span class="kw">using namespace</span> std;

<span class="tp">int</span> <span class="fn">main</span>() {
    stack&lt;<span class="tp">int</span>&gt; s;

    s.<span class="fn">push</span>(<span class="nm">10</span>);    <span class="cm">// add 10</span>
    s.<span class="fn">push</span>(<span class="nm">20</span>);    <span class="cm">// add 20</span>
    s.<span class="fn">push</span>(<span class="nm">30</span>);    <span class="cm">// add 30</span>

    cout &lt;&lt; s.<span class="fn">top</span>();   <span class="cm">// 30 (last added)</span>
    s.<span class="fn">pop</span>();           <span class="cm">// remove 30</span>
    cout &lt;&lt; s.<span class="fn">top</span>();   <span class="cm">// 20 (now on top)</span>

    <span class="kw">return</span> <span class="nm">0</span>;
}</pre></div>
      </div>

      <div class="callout callout-note">
        <div class="callout-label">ğŸ“Œ Real Life Uses</div>
        Undo button (Ctrl+Z), browser back button, function call memory, expression evaluation
      </div>
    </div>
  </div>

  <!-- =================== CHAPTER 4: QUEUE =================== -->
  <div class="chapter" id="ch4">
    <div class="chapter-header">
      <div class="chapter-num">04</div>
      <div>
        <div class="chapter-title">Queue</div>
        <div class="chapter-subtitle">First In, First Out â€” like a queue at a shop</div>
      </div>
    </div>

    <div class="section">
      <h3>What is a Queue?</h3>
      <p>A queue is a linear data structure where elements are added at the <strong>rear (back)</strong> and removed from the <strong>front</strong>. It follows the <strong>FIFO</strong> principle â€” First In, First Out.</p>

      <div class="analogy">
        <div class="analogy-label">ğŸª Analogy</div>
        <p>Think of a queue at a shop. The first person who joins the line is the first person to be served. New people join at the back. Fair and orderly!</p>
      </div>

      <div class="mem-diagram">
        <div class="mem-title">Queue Operations</div>
<pre style="color:#2a1f0f;font-size:0.82rem;line-height:2;">
enqueue(10,20,30)     dequeue()       dequeue()
FRONT        BACK     FRONT  BACK     FRONT BACK
[10][20][30]          [20][30]         [30]
 â†‘                     â†‘               â†‘
 10 removed first!     20 removed!     only 30 left
</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><div class="code-dot dot-r"></div><div class="code-dot dot-y"></div><div class="code-dot dot-g"></div>queue.cpp</div>
        <div class="code-body"><pre><span class="kw">#include</span><span class="st">&lt;iostream&gt;</span>
<span class="kw">#include</span><span class="st">&lt;queue&gt;</span>
<span class="kw">using namespace</span> std;

<span class="tp">int</span> <span class="fn">main</span>() {
    queue&lt;<span class="tp">int</span>&gt; q;

    q.<span class="fn">push</span>(<span class="nm">10</span>);   <span class="cm">// add to back</span>
    q.<span class="fn">push</span>(<span class="nm">20</span>);
    q.<span class="fn">push</span>(<span class="nm">30</span>);

    cout &lt;&lt; q.<span class="fn">front</span>();  <span class="cm">// 10 (first added)</span>
    q.<span class="fn">pop</span>();             <span class="cm">// remove 10</span>
    cout &lt;&lt; q.<span class="fn">front</span>();  <span class="cm">// 20 (now at front)</span>

    <span class="kw">return</span> <span class="nm">0</span>;
}</pre></div>
      </div>

      <table class="comp-table">
        <thead><tr><th></th><th>Stack</th><th>Queue</th></tr></thead>
        <tbody>
          <tr><td>Principle</td><td>LIFO (Last In First Out)</td><td>FIFO (First In First Out)</td></tr>
          <tr><td>Add</td><td>push (top)</td><td>push (back)</td></tr>
          <tr><td>Remove</td><td>pop (top)</td><td>pop (front)</td></tr>
          <tr><td>Analogy</td><td>Stack of plates</td><td>Queue at shop</td></tr>
          <tr><td>Use case</td><td>Undo, backtracking</td><td>Printing, scheduling</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- =================== CHAPTER 5: TREES =================== -->
  <div class="chapter" id="ch5">
    <div class="chapter-header">
      <div class="chapter-num">05</div>
      <div>
        <div class="chapter-title">Trees</div>
        <div class="chapter-subtitle">Non-linear hierarchical data structure</div>
      </div>
    </div>

    <div class="section">
      <h3>What is a Tree?</h3>
      <p>A tree is a <strong>non-linear</strong> data structure where data is organized in a <strong>hierarchy</strong>. It consists of nodes connected by edges, with one special node called the <strong>root</strong> at the top.</p>

      <div class="mem-diagram">
        <div class="mem-title">Binary Tree Structure</div>
<pre style="color:#2a1f0f;font-size:0.82rem;line-height:2;">
            [10]          â† Root
           /    \
        [20]    [30]      â† Children of root
        /  \    /  \
      [40][50][60][70]    â† Leaf nodes (no children)

Root    = top node (10)
Parent  = node with children (10, 20, 30)
Child   = node below parent
Leaf    = node with no children (40,50,60,70)
</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><div class="code-dot dot-r"></div><div class="code-dot dot-y"></div><div class="code-dot dot-g"></div>binary_tree.cpp</div>
        <div class="code-body"><pre><span class="kw">struct</span> <span class="tp">Node</span> {
    <span class="tp">int</span> data;
    <span class="tp">Node</span>* left;    <span class="cm">// left child</span>
    <span class="tp">Node</span>* right;   <span class="cm">// right child</span>

    <span class="fn">Node</span>(<span class="tp">int</span> val) {
        data  = val;
        left  = <span class="kw">nullptr</span>;
        right = <span class="kw">nullptr</span>;
    }
};

<span class="tp">int</span> <span class="fn">main</span>() {
    <span class="tp">Node</span>* root       = <span class="kw">new</span> <span class="tp">Node</span>(<span class="nm">10</span>);
    root->left        = <span class="kw">new</span> <span class="tp">Node</span>(<span class="nm">20</span>);
    root->right       = <span class="kw">new</span> <span class="tp">Node</span>(<span class="nm">30</span>);
    root->left->left  = <span class="kw">new</span> <span class="tp">Node</span>(<span class="nm">40</span>);
    root->left->right = <span class="kw">new</span> <span class="tp">Node</span>(<span class="nm">50</span>);
    <span class="kw">return</span> <span class="nm">0</span>;
}</pre></div>
      </div>
    </div>
  </div>

  <!-- =================== SUMMARY =================== -->
  <div class="chapter" id="summary">
    <div class="chapter-header">
      <div class="chapter-num">ğŸ“‹</div>
      <div>
        <div class="chapter-title">Complete Summary</div>
        <div class="chapter-subtitle">Everything in one place</div>
      </div>
    </div>

    <table class="comp-table">
      <thead>
        <tr><th>Structure</th><th>Type</th><th>Access</th><th>Insert</th><th>Delete</th><th>Use When</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Static Array</strong></td>
          <td><span class="badge badge-blue">Linear</span></td>
          <td><span class="badge badge-green">O(1) Fast</span></td>
          <td><span class="badge badge-red">O(n) Slow</span></td>
          <td><span class="badge badge-red">O(n) Slow</span></td>
          <td>Fixed size, frequent access</td>
        </tr>
        <tr>
          <td><strong>Dynamic Array</strong></td>
          <td><span class="badge badge-blue">Linear</span></td>
          <td><span class="badge badge-green">O(1) Fast</span></td>
          <td><span class="badge badge-red">O(n) Slow</span></td>
          <td><span class="badge badge-red">O(n) Slow</span></td>
          <td>Unknown size, frequent access</td>
        </tr>
        <tr>
          <td><strong>Singly Linked</strong></td>
          <td><span class="badge badge-blue">Linear</span></td>
          <td><span class="badge badge-red">O(n) Slow</span></td>
          <td><span class="badge badge-green">O(1) Fast</span></td>
          <td><span class="badge badge-green">O(1) Fast</span></td>
          <td>Frequent insert/delete</td>
        </tr>
        <tr>
          <td><strong>Doubly Linked</strong></td>
          <td><span class="badge badge-blue">Linear</span></td>
          <td><span class="badge badge-red">O(n) Slow</span></td>
          <td><span class="badge badge-green">O(1) Fast</span></td>
          <td><span class="badge badge-green">O(1) Fast</span></td>
          <td>Need bidirectional traversal</td>
        </tr>
        <tr>
          <td><strong>Stack</strong></td>
          <td><span class="badge badge-blue">Linear</span></td>
          <td>Top only</td>
          <td><span class="badge badge-green">O(1) Fast</span></td>
          <td><span class="badge badge-green">O(1) Fast</span></td>
          <td>LIFO operations</td>
        </tr>
        <tr>
          <td><strong>Queue</strong></td>
          <td><span class="badge badge-blue">Linear</span></td>
          <td>Front only</td>
          <td><span class="badge badge-green">O(1) Fast</span></td>
          <td><span class="badge badge-green">O(1) Fast</span></td>
          <td>FIFO operations</td>
        </tr>
        <tr>
          <td><strong>Tree</strong></td>
          <td><span class="badge badge-yellow">Non-Linear</span></td>
          <td>O(log n)</td>
          <td>O(log n)</td>
          <td>O(log n)</td>
          <td>Hierarchical data</td>
        </tr>
      </tbody>
    </table>

    <div class="callout callout-tip" style="margin-top:30px;">
      <div class="callout-label">ğŸ“ Learning Path</div>
      Array â†’ Linked List â†’ Stack â†’ Queue â†’ Tree â†’ Graph â†’ Hash Table
    </div>
  </div>

</div>
</body>
</html>